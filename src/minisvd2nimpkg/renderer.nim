## Copyright 2024 Dean Hall, all rights reserved.  See LICENSE.txt for details.
##
## renderer.nim
##
## Renders the output of the parser's parseSvdFile() to a Nim source package.
##
## renderNimPackageFromParsedSvd() is the only entry point to this module.
## It takes the arguments outPath and svdDevice
## and produces a nimble-compliant package of nim source code.
## outPath is a path of where to put the new nimble package directory:
##
##    <outPath>/<yourDevice>/<package files>
##
## where <yourDevice> is determined by the SVD file contents;
## it is the lowercase of the XML: <device>.<name>'s innerText.
##
## The package declares one special module, `device` and a module
## for every peripheral described in the SVD file.  The `device` module
## contains constants related to the device and cpu.  Peripherals reside
## in a module matching their name.  Enumerated peripherals are grouped into
## a single module named after the peripheral, less the number.  For example,
## peripherals SPI1, SPI2 ... SPIn reside in spi.nim.
##
## The resulting Nimble-compliant package may be installed like any other package
## or added to a project as a dependency in source form.
##

import std/[algorithm, dirs, files, os, paths, strformat, strutils, tables]

import svd_spec, svdtypes, versions

using
  device: SvdElementValue
  devicePath: Path
  outPath: Path
  outf: File
  peripheral: SvdElementValue
  interrupt: SvdElementValue
  register: SvdElementValue
  field: SvdElementValue
  access: SvdAccess

const importMetaGenerator =
  """# To learn how to use the output of the declarations below, visit:
# https://github.com/dwhall/minisvd2nim/blob/main/README.md#how-to-access-the-device

import metagenerator

"""

proc renderPackageFile(devicePath, device)
proc renderReadme(devicePath, device)
proc renderLicense(devicePath)
proc renderDevice(devicePath, device)
proc renderPeripherals(devicePath, device)
proc renderPeripheral(outf, device, peripheral)
proc renderInterrupt(outf, device, peripheral, interrupt)
proc renderRegister(outf, device, peripheral, register)
proc renderField(outf, device, peripheral, register, field)
func getPeripheralBaseName(p: SvdElementValue): string

func readAccess(access): bool =
  access == readOnly or access == readWrite or access == readWriteOnce
func writeAccess(access): bool =
  access == writeOnly or access == readWrite or access == readWriteOnce

func removeWhitespace(s: string): string =
  ## Converts all whitespace to a single space
  s.splitWhitespace.join(" ")

func getAccess(elements: varargs[ptr SvdElementValue]): SvdAccess =
  ## Returns the access value from the tail-most argument that exists.
  ## If none of the arguments has an access field,
  ## returns read-write access as default.
  ## The caller MUST order the elements: device, peripheral, register, field
  ## in order for the access to be determined correctly.
  const defaultAccess = SvdAccess.readWrite
  let els = elements.reversed()
  for el in els:
    let accessEl = el[].getElement("access")
    if accessEl != nilElementValue:
      return parseEnum[SvdAccess](accessEl.value)
  return defaultAccess

proc renderNimPackageFromParsedSvd*(outPath, device): Path =
  ## Renders the Nim device package at the outPath path.
  ## The result is a nimblec-compliant package:
  ##    <outPath>/<device.name.toLower>/
  ##        <device.name.toLower>.nimble
  ##        device.nim
  ##        toLower(<peripheral.name>).nim
  ##        ...
  ##
  assert dirExists(outPath)
  assert device.name == "device",
    "Expected top-level element, 'device', got: " & device.name
  let deviceName = device.getElement("name").value
  let devicePath = outPath / Path(deviceName.toLower())
  if dirExists(devicePath):
    stderr.write(&"Exiting.  Target path already exists: {devicePath.string}")
    quit(QuitFailure)
  createDir(devicePath)
  renderPackageFile(devicePath, device)
  renderReadme(devicePath, device)
  renderLicense(devicePath)
  renderDevice(devicePath, device)
  renderPeripherals(devicePath, device)
  result = devicePath

proc renderPackageFile(devicePath, device) =
  let deviceName = device.getElement("name").value
  let packageFn = devicePath / Path(deviceName.toLower()).addFileExt("nimble")
  var outf: File
  assert outf.open(packageFn.string, fmWrite)
  defer:
    outf.close()
  outf.write(
    &"""
#!fmt: off

version       = {getVersion().strip()}  # same as minisvd2nim's version
author        = "minisvd2nim (generated)"
description   = "Device and peripheral modules for the {deviceName}."
license       = "MIT"

requires
  "minisvd2nim >= 1.0.0"
  "nim >= 2.0.0"
"""
  )

proc renderReadme(devicePath, device) =
  let filenameParts = getAppFilename().splitFile()
  let toolName = filenameParts.name & filenameParts.ext
  let readme = devicePath / Path("README.txt")
  var outf: File
  assert outf.open(readme.string, fmWrite)
  defer:
    outf.close()
  outf.write(
    &"""
This package is auto-generated by minisvd2nim, https://github.com/dwhall/minisvd2nim
Edits will be lost if the tool is run again.

Tool:                 {toolName}
Tool version:         {getVersion().strip()}
Tool args:            {commandLineParams()}
Input file version:   {device.getElement("version").value}
"""
  )

proc renderLicense(devicePath) =
  const licenseFileContents =
    """Copyright 2024 Dean Hall

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """
  let licenseFn = devicePath / Path("LICENSE.txt")
  var outf: File
  assert outf.open(licenseFn.string, fmWrite)
  defer:
    outf.close()
  outf.write(licenseFileContents)

template castElementValue(specName: untyped, elName: string): untyped =
  ## Cast an element's string value to the type declared by the spec.
  ## Only bool for now (0/1 or false/true --> Nim bool).
  when specElementTypeIsBool(astToStr(specName), elName):
    specName.getElement(elName).value.toLowerAscii in ["true", "1"]
  else:
    specName.getElement(elName).value

proc renderDevice(devicePath, device) =
  let fn = devicePath / Path("device.nim")
  var outf: File
  assert outf.open(fn.string, fmWrite)
  defer:
    outf.close()
  let deviceName = device.getElement("name").value
  let cpu = device.getElement("cpu")
  let mpuPresent = castElementValue(cpu, "mpuPresent")
  let fpuPresent = castElementValue(cpu, "mpuPresent")
  let nvicPrioBits = cpu.getElement("nvicPrioBits").value
  outf.write(
    importMetaGenerator & &"#!fmt: off\n" &
      &"declareDevice(deviceName = {deviceName}, mpuPresent = {mpuPresent}, fpuPresent = {fpuPresent}, nvicPrioBits = {nvicPrioBits})\p"
  )

proc renderPeripherals(devicePath, device) =
  ## Write distinct peripherals to their own module.
  ## Write enumerated peripherals to a common module
  ## (e.g. SPI1, SPI2, SPIn are written to spi.nim).
  var outf: File
  for k, p in device.getElement("peripherals").elements.pairs:
    assert p.name == "peripheral"
    let lowerPeriphName = getPeripheralBaseName(p).toLower
    let periphModule = devicePath / Path(lowerPeriphName).addFileExt("nim")
    let exists = fileExists(periphModule)
    assert outf.open(periphModule.string, fmAppend)
    if not exists:
      outf.write(importMetaGenerator)
      outf.write("#!fmt: off\n")
    outf.renderPeripheral(device, p)
    outf.close()

func getPeripheralBaseName(p: SvdElementValue): string =
  ## Removes digits from the tail of the peripheral's name.
  ## Returns the possibly shortened peripheral name.
  assert p.name == "peripheral"
  let fullName = p.getElement("name").value
  var i = len(fullName) - 1
  while i > 0 and fullName[i].isDigit:
    dec i
  result = fullName[0 .. i]

proc renderPeripheral(outf, device, peripheral) =
  let peripheralName = peripheral.getElement("name").value
  let baseAddress = peripheral.getElement("baseAddress").value
  let workingPeripheral =
    if peripheral.hasAttr("derivedFrom"):
      let parentPeriphName = peripheral.getAttr("derivedFrom").value
      device.getElement("peripherals").getElement(parentPeriphName)
    else:
      peripheral
  let description = workingPeripheral.getElement("description").value.removeWhitespace()
  outf.write(
    &"declarePeripheral(peripheralName = {peripheralName}, baseAddress = {baseAddress}'u32, peripheralDesc = \"{description}\")\p"
  )
  for _, el in peripheral.elements.pairs:
    if el.name == "interrupt":
      renderInterrupt(outf, device, peripheral, el)
  for _, reg in workingPeripheral.getElement("registers").elements.pairs:
    renderRegister(outf, device, peripheral, reg)

proc renderInterrupt(outf, device, peripheral, interrupt) =
  let peripheralName = peripheral.getElement("name").value
  let interruptName = interrupt.getElement("name").value
  let interruptValue = interrupt.getElement("value").value
  let description = interrupt.getElement("description").value.removeWhitespace()
  outf.write(
    &"declareInterrupt(peripheralName = {peripheralName}, interruptName = {interruptName}, interruptValue = {interruptValue}, interruptDesc = \"{description}\")\p"
  )

proc renderRegister(outf, device, peripheral, register) =
  let peripheralName = peripheral.getElement("name").value
  let registerName = register.getElement("name").value
  let addressOffset = register.getElement("addressOffset").value
  let registerAccess = getAccess(addr device, addr peripheral, addr register)
  let description = register.getElement("description").value.removeWhitespace()
  let derivedFrom = register.getAttr("derivedFrom").value
  let declaration =
    if register.hasAttr("derivedFrom"):
      &"declareRegister(peripheralName = {peripheralName}, registerName = {registerName}, addressOffset = {addressOffset}'u32, readAccess = {readAccess(registerAccess)}, writeAccess = {writeAccess(registerAccess)}, registerDesc = \"{description}\", derivedFrom = {derivedFrom})\p"
    else:
      &"declareRegister(peripheralName = {peripheralName}, registerName = {registerName}, addressOffset = {addressOffset}'u32, readAccess = {readAccess(registerAccess)}, writeAccess = {writeAccess(registerAccess)}, registerDesc = \"{description}\")\p"
  outf.write(declaration)
  for _, f in register.getElement("fields").elements.pairs:
    renderField(outf, device, peripheral, register, f)

proc computeFieldBitRange(field: SvdElementValue): tuple[bitOffsetStr: string, bitWidthStr: string] =
  ## Determine bitOffset and bitWidth from one of the allowed SVD representations:
  ##  - explicit bitOffset and bitWidth
  ##  - lsb and msb pair
  ##  - bitRange (patterns like "lsb:msb" or "[msb:lsb]" etc.)
  var bitOffsetStr = "0"
  var bitWidthStr  = "1"

  let bitOffsetEl = field.getElement("bitOffset")
  let bitWidthEl  = field.getElement("bitWidth")
  let lsbEl       = field.getElement("lsb")
  let msbEl       = field.getElement("msb")
  let bitRangeEl  = field.getElement("bitRange")

  if bitOffsetEl != nilElementValue and bitWidthEl != nilElementValue:
    bitOffsetStr = bitOffsetEl.value
    bitWidthStr  = bitWidthEl.value
  elif lsbEl != nilElementValue and msbEl != nilElementValue:
    let l = parseInt(lsbEl.value)
    let m = parseInt(msbEl.value)
    assert m >= l
    let offset = l
    let width  = m - l + 1
    bitOffsetStr = $offset
    bitWidthStr  = $width
  elif bitRangeEl != nilElementValue:
    var br = bitRangeEl.value.strip()
    # remove optional surrounding brackets, then split on ':'
    br = br.replace("[", "").replace("]", "")
    let parts = br.split(':')
    assert parts.len == 2
    let a = parseInt(parts[0].strip())
    let b = parseInt(parts[1].strip())
    let offset = if a < b: a else: b
    let width  = if b >= a: (b - a + 1) else: (a - b + 1)
    bitOffsetStr = $offset
    bitWidthStr  = $width
  return (bitOffsetStr, bitWidthStr)

proc renderField(outf, device, peripheral, register, field) =
  # FIXME: Handle derivedFrom
  if field.hasAttr("derivedFrom"):
    stderr.write(
      &"Warning: field {peripheral.getElement(\"name\").value}.{register.getElement(\"name\").value}.{field.getElement(\"name\").value} has derivedFrom attribute, which is not yet supported.\p"
    )
  let peripheralName = peripheral.getElement("name").value
  let registerName = register.getElement("name").value
  let fieldName = field.getElement("name").value
  let (bitOffset, bitWidth) = computeFieldBitRange(field)
  let fieldAccess = getAccess(addr device, addr peripheral, addr register, addr field)
  let description = field.getElement("description").value.removeWhitespace()
  outf.write(
    &"declareField(peripheralName = {peripheralName}, registerName = {registerName}, fieldName = {fieldName}, bitOffset = {bitOffset}, bitWidth = {bitWidth}, readAccess = {readAccess(fieldAccess)}, writeAccess = {writeAccess(fieldAccess)}, fieldDesc = \"{description}\")\p"
  )
  let enumElements = field.getElement("enumeratedValues").elements
  if enumElements.len > 0:
    outf.write(
      &"declareFieldEnum(peripheralName = {peripheralName}, registerName = {registerName}, fieldName = {fieldName}, bitOffset = {bitOffset}, bitWidth = {bitWidth}):\p"
    )
    for name, enumElement in enumElements.pairs:
      let enumValue = enumElement.getElement("value").value
      outf.write(&"  {name} = {enumValue}\p")
