## Copyright 2024 Dean Hall, all rights reserved.  See LICENSE.txt for details.
##
## renderer.nim
##
## Renders the output of the parser's parseSvdFile() to a Nim source package.
##
## renderNimPackageFromParsedSvd() is the only entry point to this module.
## It takes the arguments outPath and svdDevice
## and produces a nimble-compliant package of nim source code.
## outPath is a path of where to put the new nimble package directory:
##
##    <outPath>/<yourDevice>/<package files>
##
## where <yourDevice> is determined by the SVD file contents;
## it is the lowercase of the XML: <device>.<name>'s innerText.
##
## The package declares one special module, `device` and a module
## for every peripheral described in the SVD file.  The `device` module
## contains constants related to the device and cpu.  Peripherals reside
## in a module matching their name.  Enumerated peripherals are grouped into
## a single module named after the peripheral, less the number.  For example,
## peripherals SPI1, SPI2 ... SPIn reside in spi.nim.
##
## The resulting Nimble-compliant package may be installed like any other package
## or added to a project as a dependency in source form.
##

import std/[algorithm, files, os, paths, sets, strformat, strutils, tables]

import svd_spec, svd_types, utils, versions

using
  device: SvdElementValue
  deviceName: string
  pkgPath: Path
  outPath: Path
  outf: File
  peripheral: SvdElementValue
  interrupt: SvdElementValue
  register: SvdElementValue
  registerName: string
  field: SvdElementValue
  access: SvdAccess

const importMetaGenerator =
  """# To learn how to use the output of the declarations below, visit:
# https://github.com/dwhall/minisvd2nim/blob/main/README.md#how-to-access-the-device

import metagenerator

"""

proc renderPackageFile(pkgPath, device, deviceName)
proc renderReadme(pkgPath, device)
proc renderLicense(pkgPath)
proc renderDevice(pkgPath, device)
proc renderCpu(outf, device)
proc renderPeripherals(pkgPath, device)
proc renderSeggerPeripherals(pkgPath, device)
proc renderPeripheral(outf, device, peripheral)
proc renderInterrupt(outf, device, peripheral, interrupt)
proc renderRegister(outf, device, peripheral, register)
proc renderField(outf, device, peripheral, registerName, register, field)
func getPeripheralBaseName(p: SvdElementValue): string
proc removeAbsolutePath(params: var seq[string], absPath: string)

func readAccess(access): bool =
  access == readOnly or access == readWrite or access == readWriteOnce
func writeAccess(access): bool =
  access == writeOnly or access == readWrite or access == readWriteOnce

func removeWhitespace(s: string): string =
  ## Converts all whitespace to a single space
  s.splitWhitespace.join(" ")

func getAccess(elements: varargs[ptr SvdElementValue]): SvdAccess =
  ## Returns the access value from the tail-most argument that exists.
  ## If none of the arguments has an access field,
  ## returns read-write access as default.
  ## The caller MUST order the elements: device, peripheral, register, field
  ## in order for the access to be determined correctly.
  const defaultAccess = SvdAccess.readWrite
  let els = elements.reversed()
  for el in els:
    let accessEl = el[].getElement("access")
    if accessEl != nilElementValue:
      return parseEnum[SvdAccess](accessEl.value)
  return defaultAccess

proc renderNimPackageFromParsedSvd*(device, pkgPath, deviceName) =
  ## Renders the Nim device package at the outPath path.
  ## The result is a nimble-compliant package:
  ##    <outPath>/<deviceName>/
  ##        <deviceName>.nimble
  ##        device.nim
  ##        <peripheral.name.toLower()>.nim
  ##        ...
  renderPackageFile(pkgPath, device, deviceName)
  renderReadme(pkgPath, device)
  renderLicense(pkgPath)
  if not device.isSeggerVariant:
    renderDevice(pkgPath, device)
  else:
    renderSeggerPeripherals(pkgPath, device)

proc renderPackageFile(pkgPath, device, deviceName) =
  let fullVersion = getVersion().strip()
  let fileContents = &"""
#!fmt: off

version       = {fullVersion}  # same as minisvd2nim's version
author        = "minisvd2nim (generated)"
description   = "Device and peripheral modules for the {deviceName}."
license       = "MIT"

requires
  "nim >= 2.0"
"""
  var outf: File
  let packageFn = pkgPath / Path(deviceName.toLower()).addFileExt("nimble")
  assert outf.open(packageFn.string, fmWrite)
  defer:
    outf.close()
  outf.write(fileContents)

proc renderReadme(pkgPath, device) =
  let filenameParts = getAppFilename().splitFile()
  let toolName = filenameParts.name & filenameParts.ext
  let readme = pkgPath / Path("README.txt")
  var params = commandLineParams()
  let cwd = os.getCurrentDir() & DirSep
  params.removeAbsolutePath(cwd)
  var outf: File
  assert outf.open(readme.string, fmWrite)
  defer:
    outf.close()
  outf.write(
    &"""
This package is auto-generated by minisvd2nim, https://github.com/dwhall/minisvd2nim
Edits will be lost if the tool is run again.

Tool:                 {toolName}
Tool version:         {getVersion().strip()}
Tool args:            {params}
Input file version:   {device.getElement("version").value}
"""
  )

proc removeAbsolutePath(params: var seq[string], absPath: string) =
  if not os.isAbsolute(absPath): return
  for param in params.mitems:
    if absPath in param:
      param = param.replace(absPath, "")

proc renderLicense(pkgPath) =
  const licenseFileContents =
    """Copyright 2024 Dean Hall

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """
  let licenseFn = pkgPath / Path("LICENSE.txt")
  var outf: File
  assert outf.open(licenseFn.string, fmWrite)
  defer:
    outf.close()
  outf.write(licenseFileContents)

func getElementValue(el: SvdElementValue, elName: string): string =
  ## Cast an element's value to a string that represents the value
  let typeFromSpec = getSpec(el.name).getElement(elName).dataType
  let elVal = el.getElement(elName).value.toLowerAscii
  case typeFromSpec
  of svdBool:
    if elVal in ["true", "1"]: "true" else: "false"
  else:
    elVal

proc renderDevice(pkgPath, device) =
  let fn = pkgPath / Path("device.nim")
  var outf: File
  assert outf.open(fn.string, fmWrite)
  defer:
    outf.close()
  let deviceName = device.getElement("name").value
  let svdFileVersion = device.getElement("version").value
  let description = device.getElement("description").value
  outf.write(
    importMetaGenerator & &"#!fmt: off\n" &
      &"declareDevice(deviceName = {deviceName}, svdFileVersion = \"{svdFileVersion}\", description = \"{description}\")\p"
  )
  renderCpu(outf, device)
  renderPeripherals(pkgPath, device)

proc renderCpu(outf, device) =
  let cpu = device.getElement("cpu")
  let cpuName = cpu.getElement("name").value
  let revision = cpu.getElement("revision").value
  let endian = cpu.getElement("endian").value
  let mpuPresent = cpu.getElementValue("mpuPresent")
  let fpuPresent = cpu.getElementValue("fpuPresent")
  let nvicPrioBits = cpu.getElement("nvicPrioBits").value
  let vendorSysTick = cpu.getElement("vendorSystickConfig").value
  # TODO: fpuDP, deviceNumInterrupts (which optionally exist)
  outf.write(
    &"declareCpu(cpuName = {cpuName}, revision = \"{revision}\", endian = \"{endian}\", mpuPresent = {mpuPresent}, fpuPresent = {fpuPresent}, nvicPrioBits = {nvicPrioBits}, vendorSysTick = {vendorSysTick})\p"
  )

proc renderPeripherals(pkgPath, device) =
  ## Write distinct peripherals to their own module.
  ## Write enumerated peripherals to a common module
  ## (e.g. SPI1, SPI2, SPIn are written to spi.nim).
  var outf: File
  var periphFileSet = initHashSet[string]()
  for _,p in device.getElement("peripherals").elements.pairs:
    assert p.name == "peripheral"
    let lowerPeriphName = getPeripheralBaseName(p).toLower
    let periphModule = pkgPath / Path(lowerPeriphName).addFileExt("nim")
    let exists = fileExists(periphModule)
    let mode = if lowerPeriphName in periphFileSet: fmAppend else: fmWrite
    assert outf.open(periphModule.string, mode)
    if not exists:
      outf.write(importMetaGenerator)
      outf.write("#!fmt: off\n")
    outf.renderPeripheral(device, p)
    outf.close()
    periphFileSet.incl(lowerPeriphName)

proc renderSeggerPeripherals(pkgPath, device) =
  ## Write distinct peripherals to their own module.
  ## Write enumerated peripherals to a common module
  ## (e.g. SPI1, SPI2, SPIn are written to spi.nim).
  var outf: File
  var periphFileSet = initHashSet[string]()
  for _,g in device.getElement("cpu").getElement("groups").elements.pairs:
    if g.getElement("name").value.toLower() != "peripherals":
      continue
    for _,p in g.getElement("peripherals").elements.pairs:
      assert p.name == "peripheral"
      let lowerPeriphName = getPeripheralBaseName(p).toLower
      let periphModule = pkgPath / Path(lowerPeriphName).addFileExt("nim")
      let exists = fileExists(periphModule)
      let mode = if lowerPeriphName in periphFileSet: fmAppend else: fmWrite
      assert outf.open(periphModule.string, mode)
      if not exists:
        outf.write(importMetaGenerator)
        outf.write("#!fmt: off\n")
      outf.renderPeripheral(device, p)
      outf.close()
      periphFileSet.incl(lowerPeriphName)

func getPeripheralBaseName(p: SvdElementValue): string =
  ## Removes digits from the tail of the peripheral's name.
  ## Returns the possibly shortened peripheral name.
  assert p.name == "peripheral"
  let fullName = p.getElement("name").value
  var i = len(fullName) - 1
  while i > 0 and fullName[i].isDigit:
    dec i
  result = fullName[0 .. i]

proc renderPeripheral(outf, device, peripheral) =
  let peripheralName = peripheral.getElement("name").value
  let baseAddress = peripheral.getElement("baseAddress").value
  let workingPeripheral =
    if peripheral.hasAttr("derivedFrom"):
      let parentPeriphName = peripheral.getAttr("derivedFrom").value
      device.getElement("peripherals").getElement(parentPeriphName)
    else:
      peripheral
  let description = workingPeripheral.getElement("description").value.removeWhitespace()
  outf.write(
    &"declarePeripheral(peripheralName = {peripheralName}, baseAddress = {baseAddress}'u32, peripheralDesc = \"{description}\")\p"
  )
  for _, el in peripheral.elements.pairs:
    if el.name == "interrupt":
      renderInterrupt(outf, device, peripheral, el)
  for _, reg in workingPeripheral.getElement("registers").elements.pairs:
    renderRegister(outf, device, peripheral, reg)

proc renderInterrupt(outf, device, peripheral, interrupt) =
  let peripheralName = peripheral.getElement("name").value
  let interruptName = interrupt.getElement("name").value
  let interruptValue = interrupt.getElement("value").value
  let description = interrupt.getElement("description").value.removeWhitespace()
  outf.write(
    &"declareInterrupt(peripheralName = {peripheralName}, interruptName = {interruptName}, interruptValue = {interruptValue}, interruptDesc = \"{description}\")\p"
  )

proc renderRegister(outf, device, peripheral, register) =
  let isDimensioned = register.getElement("dim") != nilElementValue and
    register.getElement("dimIncrement") != nilElementValue
  let peripheralName = peripheral.getElement("name").value
  var registerName = register.getElement("name").value
  if " " in registerName:
    registerName = register.getElement("displayName").value
  let addressOffset = register.getElement("addressOffset").value
  let registerAccess = getAccess(addr device, addr peripheral, addr register)
  let description = register.getElement("description").value.removeWhitespace()
  let derivedFrom = register.getAttr("derivedFrom").value
  let derivedFromSnippet = if register.hasAttr("derivedFrom"): &", derivedFrom = {derivedFrom}" else: ""
  # TODO: address test_renderer.nim:27
  # TODO: a derivedFrom register should copy all elements from the source register
  if isDimensioned:
    let dim = parseAnyInt(register.getElement("dim").value)
    let dimIncrement = parseAnyInt(register.getElement("dimIncrement").value)
    var addressOffsetVal = parseAnyInt(addressOffset)
    let registerNameWithoutBrackets = registerName.replace("[%s]", "%s")
    var regNameFmt = registerNameWithoutBrackets.replace("%s", "$1")
    for i in 0 ..< dim:
      let regName = `%`(regNameFmt, $i)
      outf.write(
        &"declareRegister(peripheralName = {peripheralName}, registerName = {regName}, addressOffset = 0x{addressOffsetVal.toHex}'u32, readAccess = {readAccess(registerAccess)}, writeAccess = {writeAccess(registerAccess)}, registerDesc = \"{description}\"{derivedFromSnippet})\p"
      )
      for _, field in register.getElement("fields").elements.pairs:
        renderField(outf, device, peripheral, regName, register, field)
      addressOffsetVal += dimIncrement
  else:
    outf.write(
      &"declareRegister(peripheralName = {peripheralName}, registerName = {registerName}, addressOffset = {addressOffset}'u32, readAccess = {readAccess(registerAccess)}, writeAccess = {writeAccess(registerAccess)}, registerDesc = \"{description}\"{derivedFromSnippet})\p"
    )
    for _, field in register.getElement("fields").elements.pairs:
      renderField(outf, device, peripheral, registerName, register, field)

proc computeFieldBitRange(
    field: SvdElementValue
): tuple[bitOffsetStr: string, bitWidthStr: string] =
  ## Determine bitOffset and bitWidth from one of the allowed SVD representations:
  ##  - explicit bitOffset and bitWidth
  ##  - lsb and msb pair
  ##  - bitRange (patterns like "lsb:msb" or "[msb:lsb]" etc.)
  var bitOffsetStr = "0"
  var bitWidthStr = "1"

  let bitOffsetEl = field.getElement("bitOffset")
  let bitWidthEl = field.getElement("bitWidth")
  let lsbEl = field.getElement("lsb")
  let msbEl = field.getElement("msb")
  let bitRangeEl = field.getElement("bitRange")

  if bitOffsetEl != nilElementValue and bitWidthEl != nilElementValue:
    bitOffsetStr = bitOffsetEl.value
    bitWidthStr = bitWidthEl.value
  elif lsbEl != nilElementValue and msbEl != nilElementValue:
    let l = parseInt(lsbEl.value)
    let m = parseInt(msbEl.value)
    assert m >= l
    let offset = l
    let width = m - l + 1
    bitOffsetStr = $offset
    bitWidthStr = $width
  elif bitRangeEl != nilElementValue:
    var br = bitRangeEl.value.strip()
    # remove optional surrounding brackets, then split on ':'
    br = br.replace("[", "").replace("]", "")
    let parts = br.split(':')
    assert parts.len == 2
    let a = parseInt(parts[0].strip())
    let b = parseInt(parts[1].strip())
    let offset = if a < b: a else: b
    let width =
      if b >= a:
        (b - a + 1)
      else:
        (a - b + 1)
    bitOffsetStr = $offset
    bitWidthStr = $width
  return (bitOffsetStr, bitWidthStr)

proc renderField(outf, device, peripheral, registerName, register, field) =
  # FIXME: Handle derivedFrom
  if field.hasAttr("derivedFrom"):
    stderr.write(
      &"Warning: field {peripheral.getElement(\"name\").value}.{register.getElement(\"name\").value}.{field.getElement(\"name\").value} has derivedFrom attribute, which is not yet supported.\p"
    )
  let isDimensioned = field.getElement("dim") != nilElementValue and
    field.getElement("dimIncrement") != nilElementValue
  let peripheralName = peripheral.getElement("name").value
  const fieldNameReplacements = [ # Order is important
    (", ", "_"),
    (" & ", "_"),
    (" ", "_"),
  ]
  var fieldName = field.getElement("name").value
  for (match, replacement) in fieldNameReplacements:
    fieldName = fieldName.replace(match, replacement)
  let (bitOffset, bitWidth) = computeFieldBitRange(field)
  let fieldAccess = getAccess(addr device, addr peripheral, addr register, addr field)
  let description = field.getElement("description").value.removeWhitespace()
  if isDimensioned:
    let dim = parseAnyInt(field.getElement("dim").value)
    let dimIncrement = parseAnyInt(field.getElement("dimIncrement").value)
    var bitOffsetVal = parseAnyInt(bitOffset)
    fieldName = fieldName.replace("[%s]", "%s")
    var fieldNameFmt = fieldName.replace("%s", "$1")
    for i in 0 ..< dim:
      fieldName = `%`(fieldNameFmt, $i)
      outf.write(
        &"declareField(peripheralName = {peripheralName}, registerName = {registerName}, fieldName = {fieldName}, bitOffset = {bitOffsetVal}, bitWidth = {bitWidth}, readAccess = {readAccess(fieldAccess)}, writeAccess = {writeAccess(fieldAccess)}, fieldDesc = \"{description}\")\p"
      )
      bitOffsetVal += dimIncrement
  else:
    outf.write(
      &"declareField(peripheralName = {peripheralName}, registerName = {registerName}, fieldName = {fieldName}, bitOffset = {bitOffset}, bitWidth = {bitWidth}, readAccess = {readAccess(fieldAccess)}, writeAccess = {writeAccess(fieldAccess)}, fieldDesc = \"{description}\")\p"
    )
  # FIXME: enum's fieldName only matches with non-dimensioned fields
  let enumElements = field.getElement("enumeratedValues").elements
  if enumElements.len > 0:
    outf.write(
      &"declareFieldEnum(peripheralName = {peripheralName}, registerName = {registerName}, fieldName = {fieldName}, bitOffset = {bitOffset}, bitWidth = {bitWidth}):\p"
    )
    for name, enumElement in enumElements.pairs:
      let enumValue = enumElement.getElement("value").value
      outf.write(&"  {name} = {enumValue}\p")
