## These templates are not used by the minisvd2nim program.
## Instead, these templates are used by the code generated by minisvd2nim.
## This allows the programmer to change the final form of the Nim source
## without changing and recompiling minisvd2nim.

import std/bitops
import std/volatile

# First some types that the templates will need
type RegisterVal = uint32

template declareDevice*(
    deviceName: untyped,
    mpuPresent: static bool,
    fpuPresent: static bool,
    nvicPrioBits: static int,
): untyped =
  # Device details
  const DEVICE* {.inject.} = astToStr(deviceName)
  const MPU_PRESET* {.inject.} = mpuPresent
  const FPU_PRESENT* {.inject.} = fpuPresent
  const NVIC_PRIO_BITS* {.inject.} = nvicPrioBits

template declarePeripheral*(
    peripheralName: untyped, baseAddress: static uint32, peripheralDesc: static string
): untyped =
  type `peripheralName Base` {.inject.} = distinct RegisterVal
  const peripheralName* {.inject.} = `peripheralName Base`(baseAddress)

template declareInterrupt*(
    peripheralName: untyped,
    interruptName: untyped,
    interruptValue: static int,
    interruptDesc: static string,
): untyped =
  const `irq interruptName`* {.inject.} = interruptValue # `interruptDesc`

template declareRegister*(
    peripheralName: untyped,
    registerName: untyped,
    addressOffset: static uint32,
    readAccess: static bool,
    writeAccess: static bool,
    registerDesc: static string,
): untyped =
  type `peripheralName _ registerName Val`* {.inject.} = distinct RegisterVal
  type `peripheralName _ registerName Ptr` {.inject.} =
    ptr `peripheralName _ registerName Val`

  const `peripheralName _ registerName` {.inject.} =
    cast[`peripheralName _ registerName Ptr`](`peripheralName`.uint32 + addressOffset)

  when readAccess:
    template `registerName`*(
        base: static `peripheralName Base`
    ): `peripheralName _ registerName Val` =
      volatileLoad(`peripheralName _ registerName`)

  when writeAccess:
    template `registerName=`*(
        base: static `peripheralName Base`, val: `peripheralName _ registerName Val`
    ) =
      volatileStore(`peripheralName _ registerName`, val)

    template `registerName=`*(base: static `peripheralName Base`, val: uint32) =
      volatileStore(`peripheralName _ registerName`, `peripheralName _ registerName Val`(val))

    template write*(regVal: `peripheralName _ registerName Val`) =
      volatileStore(`peripheralName _ registerName`, regVal)

func getField[T](regVal: T, bitOffset: static int, bitWidth: static int): T {.inline.} =
  ## Returns the field from the regVal and down-shifts it to no bit offset
  doAssert bitOffset >= 0, "bitOffset must not be negative"
  doAssert bitOffset < sizeof(RegisterVal) * 8, "bitOffset exceeds register size"
  doAssert bitWidth > 0, "bitWidth must be greater than zero"
  doAssert bitWidth < sizeof(RegisterVal) * 8, "bitWidth exceeds register size"
  const bitEnd = bitOffset + bitWidth - 1
  doAssert bitEnd >= 0, "bitEnd must not be negative"
  doAssert bitEnd < 32, "bit mask does not fit within u32"
  const bitMask = toMask[uint32](bitOffset .. bitEnd)
  var r = regVal.RegisterVal
  r = r and bitMask
  r = r shr bitOffset
  r.T

func setField[T](
    regVal: T, bitOffset: static int, bitWidth: static int, fieldVal: RegisterVal
): T {.inline.} =
  ## Puts the fieldVal into only the offset+width-bits of the given regVal.
  ## Incoming fieldVal is bit-0-based (not yet shifted into final position)
  doAssert bitOffset >= 0, "bitOffset must not be negative"
  doAssert bitOffset < sizeof(RegisterVal) * 8, "bitOffset exceeds register size"
  doAssert bitWidth > 0, "bitWidth must be greater than zero"
  doAssert bitWidth < sizeof(RegisterVal) * 8, "bitWidth exceeds register size"
  const bitEnd = bitOffset + bitWidth - 1
  doAssert bitEnd >= 0, "bitEnd must not be negative"
  doAssert bitEnd < 32, "bit mask does not fit within u32"
  const bitMask = toMask[uint32](bitOffset .. bitEnd)
  # TODO: how should we handle a runtime value that exceeds bitWidth?
  # assert(((fieldVal shl bitOffset) and bitnot(bitMask)) == 0, "fieldVal exceeds bitWidth")
  var r = regVal.RegisterVal
  r = r and bitnot(bitMask)
  r = r or ((fieldVal shl bitOffset) and bitMask)
  r.T

template declareField*(
    peripheralName: untyped,
    registerName: untyped,
    fieldName: untyped,
    bitOffset: static int,
    bitWidth: static int,
    readAccess: static bool,
    writeAccess: static bool,
    fieldDesc: static string,
) =
  when readAccess:
    template `fieldName`*(
        regVal: `peripheralName _ registerName Val`
    ): `peripheralName _ registerName Val` =
      getField[`peripheralName _ registerName Val`](regVal, bitOffset, bitWidth)

  when writeAccess:
    template `fieldName`*(
        regVal: `peripheralName _ registerName Val`, fieldVal: uint32
    ): `peripheralName _ registerName Val` =
      setField[`peripheralName _ registerName Val`](
        regVal, bitOffset, bitWidth, fieldVal
      )
